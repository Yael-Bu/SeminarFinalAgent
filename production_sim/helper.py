"""
Helper Utilities - Production Trap Simulator
===========================================

This module serves as the foundational utility layer for the simulation. 
It provides the shared logic required for message lifecycle management, 
state consistency, and security-oriented scenario customization.

Module Responsibilities:
------------------------
1. Message Standardization: Encapsulates the creation of AI and System messages 
   with unique tracking identifiers.
2. Context Overflow Prevention: Implements logic to filter redundant messages 
   from the simulation state, ensuring high precision for LLM agents.
3. Anti-Cheat Engine: Provides the deterministic randomization logic needed to 
   generate unique student signatures, ensuring scalability and academic integrity.
"""

import uuid
import random
from typing import List
from langchain_core.messages import AIMessage, SystemMessage, BaseMessage

def create_ai_message(content: str) -> AIMessage:
    """
    Creates an AIMessage with a unique UUID for tracking and deduplication.
    
    Args:
        content (str): The text response generated by an AI agent.
        
    Returns:
        AIMessage: A message object containing the content and a unique ID.
    """
    return AIMessage(
        content=content,
        additional_kwargs={"id": str(uuid.uuid4())}
    )

def create_sys_message(content: str) -> SystemMessage:
    """
    Creates a SystemMessage with a unique ID, typically used for deterministic 
    alerts from the Production Monitor.
    
    Args:
        content (str): The technical alert or status update.
        
    Returns:
        SystemMessage: A message object representing a system-level event.
    """
    return SystemMessage(
        content=content,
        additional_kwargs={"id": str(uuid.uuid4())}
    )

def ensure_id(msg: BaseMessage) -> BaseMessage:
    """
    Ensures that a message object has a valid unique ID. 
    If missing, it generates a new UUID and assigns it.
    """
    if not getattr(msg, "id", None):
        msg.id = str(uuid.uuid4())
    return msg

def add_unique_messages(
    existing: List[BaseMessage],
    new: List[BaseMessage]
) -> List[BaseMessage]:
    """
    Filters out duplicate messages based on their unique IDs before adding to the state.
    
    This is the primary mechanism for preventing context bloating and ensuring the 
    LLM agents only process new, relevant information.
    
    Args:
        existing: The current messages in the SimulationState.
        new: The new messages to be merged.
        
    Returns:
        List[BaseMessage]: A merged list containing only unique message instances.
    """
    seen_ids = {m.id for m in existing if getattr(m, "id", None)}

    unique_new = [
        m for m in new
        if getattr(m, "id", None) not in seen_ids
    ]

    return existing + unique_new


def get_id_signature(student_id: str) -> str:
    """
    Generates a unique, deterministic 3-letter signature based on the Student ID.
    
    This function implements the 'Student Signature' logic. It ensures 
    that each student receives a unique technical namespace (e.g., Table_HGA), 
    satisfying the Anti-Cheat and Scale requirements.
    
    Technical Process:
    1. Extract numeric digits from the input ID.
    2. Seed a local random generator for consistent results per student.
    3. Shuffle digits to obfuscate the relationship between ID and signature.
    4. Map digits to letters (A-J) to create a three-letter prefix.

    Args:
        student_id (str): The unique identifier of the student.
        
    Returns:
        str: A 3-letter alphabetic signature (e.g., 'ABC').
    """
    # Extract numeric digits
    digits = [d for d in student_id if d.isdigit()]
    
    if not digits:
        return "GEN"
        
    # Seed a local random generator for consistency 
    local_random = random.Random(student_id)
    
    # Shuffle the digits for obfuscation 
    shuffled_digits = digits.copy()
    local_random.shuffle(shuffled_digits)
    
    # Map selected digits to letters A-J 
    selected_digits = shuffled_digits[:3]
    mapping = {str(i): chr(65 + i) for i in range(10)}
    
    return "".join(mapping.get(d, "X") for d in selected_digits)